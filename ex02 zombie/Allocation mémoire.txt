1) ##########

Fichiers √† rendre : Makefile, main.cpp, Zombie.{h, hpp}, Zombie.cpp,
newZombie.cpp, randomChump.cpp


Pour commencer, impl√©mentez une classe Zombie. Elle poss√®de un attribut priv√©
name (nom) de type string.

Ajoutez-lui une fonction membre void announce( void );. Les zombies se pr√©sentent
(s‚Äôannoncent) ainsi :

<nom>: BraiiiiiiinnnzzzZ...

N‚Äôaffichez pas les chevrons (< et >). Pour un zombie nomm√© Foo, le message serait :

Foo: BraiiiiiiinnnzzzZ...

Ensuite, impl√©mentez les fonctions suivantes :
	‚Ä¢ Zombie* newZombie( std::string name );
		Cr√©e un zombie, lui donne un nom et le retourne afin qu‚Äôil puisse √™tre utilis√© en dehors de la port√©e de la fonction.
	‚Ä¢ void randomChump( std::string name );
		Cr√©e un zombie, lui donne un nom et le fait se pr√©senter.

Quel est donc le but de l‚Äôexercice ? Vous devez d√©terminez dans quel cas il est plus
judicieux d‚Äôallouer les zombies sur le tas, et dans quel autre sur la pile.
Les zombies doivent √™tre d√©truits lorsque vous n‚Äôen avez plus besoin. Le destructeur
doit afficher un message de d√©bug comportant le nom du zombie.

```
#include <cstdlib> // EXIT_* MACROS
#include <iostream> // std::cin, std::cout, std::endl
#include <string>
#include <stdio.h>
#include "Zombie.hpp"

using std::cin;
using std::cout;
using std::endl;

int main(void)
{
    std::string input;

    /* STACK */
    cout << "Name the stacked Zombie üßü‚Äç‚ôÇÔ∏è: ";
    getline(cin, input);
    if (cin.eof() == true)
    {
        cin.clear();
        clearerr(stdin);
		cout << endl;
    }
    
    randomChump(input);

    /* HEAP ZOMBIE */
    cout << "Name the heap Zombie üßü‚Äç‚ôÇÔ∏è: ";
    getline(cin, input);
    if (cin.eof() == true)
    {
        cin.clear();
        clearerr(stdin);
	    cout << endl;
    }

    Zombie *new_zombie = newZombie(input);
    /* Upon main() exit, if new_zombie is not deleted
    the destructor is not called, causing a memory leak */
    delete new_zombie;

    return EXIT_SUCCESS;
}
```

2) #########

Fichiers √† rendre : Makefile, main.cpp, Zombie.{h, hpp}, Zombie.cpp,
zombieHorde.cpp

Il est maintenant temps de cr√©er une horde de Zombies !

Impl√©mentez la fonction suivante dans le fichier correspondant :
	Zombie* zombieHorde( int N, std::string name );
		Cette fonction doit allouer N objets Zombie en une seule allocation. Ensuite, elle doit initialiser les zombies en donnant √† chacun le nom pass√© en param√®tre. Elle retourne un pointeur sur le premier zombie.

√âcrivez vos propres tests afin de vous assurer que votre fonction zombieHorde() se
comporte comme demand√©. Essayez d‚Äôappeler announce() pour chacun des zombies.
N‚Äôoubliez pas de tous les delete et de v√©rifiez que vous n‚Äôavez pas de fuites de
m√©moire.


```
#include <cstdlib> // EXIT_* MACROS
#include <iostream> // std::cin, std::cout, std::endl
#include <string>
#include <stdio.h>
#include "Zombie.hpp"

using std::cin;
using std::cout;
using std::endl;

int main(void)
{
    std::string zombies_name;
    int n;

    while (1)
    {
        cout << "Name the Zombies üßü‚Äç‚ôÇÔ∏è: ";
        getline(cin, zombies_name);
        if (cin.eof() == true)
        {
            cin.clear();
            clearerr(stdin);
			cout << endl;
        }
        if (!zombies_name.empty())
            break;
        cout << "Please insert a name for the zombies" << endl;
    }

    cout << "How much zombies you'd like to have?" << endl;
    cin >> n;

    Zombie  *zombie_army = zombieHorde(n, zombies_name);

    for (int i = 0; i < n; i += 1)
        zombie_army[i].announce();

    delete[]  zombie_army;
    return EXIT_SUCCESS;
}
```


3) ##########

Fichiers √† rendre : Makefile, main.cpp, Weapon.{h, hpp}, Weapon.cpp,
HumanA.{h, hpp}, HumanA.cpp, HumanB.{h, hpp}, HumanB.cpp

Impl√©mentez une classe Weapon (arme) qui poss√®de :
‚Ä¢ Un attribut priv√© type de type string.
‚Ä¢ Une fonction membre getType() retournant une r√©f√©rence constante sur type.
‚Ä¢ Une fonction membre setType() qui attribue √† type la nouvelle valeur pass√©e en
param√®tre.

Maintenant, cr√©ez deux classes HumanA et HumanB. 

Toutes deux poss√®dent une Weapon et un name, ainsi qu‚Äôune fonction membre attack() affichant (sans les chevrons
bien s√ªr) :

<name> attacks with their <weapon type>
HumanA et HumanB sont presque identiques, √† l‚Äôexception de deux petits d√©tails :
‚Ä¢ Alors que le constructeur de HumanA prend une Weapon comme param√®tre, ce
n‚Äôest pas le cas de celui de HumanB.
‚Ä¢ HumanB n‚Äôaura pas toujours une Weapon, tandis que HumanA en aura forc√©ment une.


Si votre impl√©mentation est correcte, l‚Äôex√©cution du code suivant affichera une attaque
avec "crude spiked club", puis une attaque avec "some other type of club", pour les deux
tests :

```
int main()
{
	{
		Weapon club = Weapon("crude spiked club");
		HumanA bob("Bob", club);
		bob.attack();
		club.setType("some other type of club");
		bob.attack();
	}
	{
		Weapon club = Weapon("crude spiked club");
		HumanB jim("Jim");
		jim.setWeapon(club);
		jim.attack();
		club.setType("some other type of club");
		jim.attack();
	}
	return 0;
}

```

Dans quel cas pensez-vous plus judicieux d‚Äôutiliser un pointeur sur
Weapon ? Et une r√©f√©rence sur Weapon ? Pourquoi ? Prenez le temps d‚Äôy
r√©fl√©chir avant de commencer.
